
//Последовательности
--Пользователи

CREATE SEQUENCE sq_id_user
START WITH 1 
INCREMENT BY 1 
NOMAXVALUE;

CREATE OR REPLACE TRIGGER tr_id_user before INSERT ON tvz_tbl_users FOR each row
BEGIN
  SELECT sq_id_user.NEXTVAL
  INTO :new.id
  FROM dual;
END;


CREATE TABLE tvz_tbl_users
(
	id INTEGER GENERATED by default on null as IDENTITY,
	phone_number VARCHAR2(14),
	first_name varchar2(255),
	email VARCHAR2(14),
	beath_date varchar2(10)
)

ALTER TABLE tvz_tbl_users ADD type_user int; 			-- 0 - пользователь, 1 - Шеф
ALTER TABLE tvz_tbl_users ADD image_path varchar2(255); -- путь к файлу

-- продукты

CREATE SEQUENCE sq_id_product
START WITH 1 
INCREMENT BY 1 
NOMAXVALUE;

CREATE TABLE tvz_tbl_product
(
	id INTEGER GENERATED by default on null as IDENTITY,
	id_user integer,
	id_recept integer,
	product_name VARCHAR2(255),
	text_product varchar2(255),
	image_path  varchar2(255),
	count_porc integer,
	count_shuger integer,
	count_fruit integer,
	id_form integer,
	log_active integer,
	group_product integer
)

CREATE OR REPLACE TRIGGER tr_id_product before INSERT ON tvz_tbl_product FOR each row
BEGIN
  SELECT sq_id_product.NEXTVAL
  INTO :new.id
  FROM dual;
END;


-- Справочник групп продуктов

CREATE TABLE tvz_group_product_name (
	id integer,
	name_product_group varchar2(255)
)

SELECT rowid, t.* FROM tvz_group_product_name t

-- Состав/Рецепт

CREATE SEQUENCE sq_id_recept 
START WITH 1 
INCREMENT BY 1 
NOMAXVALUE;

CREATE TABLE tvz_tbl_recept
(
	id INTEGER GENERATED by default on null as IDENTITY,
	id_user integer,
	recept_name VARCHAR2(255),
	group_recept varchar2(255),
	id_ingredient  integer, 
	value_num float,
	count_shuger integer,
	count_fruit integer,
	id_type_recept integer, --Муссовый тор, тарт, муссовые пироженные и т.д.
	count_porc float,
	log_active integer,
	x_price float -- сложность изготовления рецепта (умножаем себестоимость на К сложности)
)

CREATE OR REPLACE TRIGGER tr_id_recept before INSERT ON tvz_tbl_recept FOR each row
BEGIN
  SELECT sq_id_recept.NEXTVAL
  INTO :new.id
  FROM dual;
END;

ALTER TABLE tvz_tbl_recept ADD log_active integer;
ALTER TABLE tvz_tbl_recept ADD x_price float;

-- Ингридиенты справочник

CREATE SEQUENCE sq_id_ingredient
START WITH 1 
INCREMENT BY 1 
NOMAXVALUE;

CREATE TABLE tvz_tbl_ingredient
(
	id INTEGER GENERATED by default on null as IDENTITY,
	id_user integer,
	ingredient_name VARCHAR2(255),
	type_value integer,
	size_value float, --(2 единицы грамм или милилитров)
	price_rub float
)

CREATE OR REPLACE TRIGGER tr_id_ingredient before INSERT ON tvz_tbl_ingredient FOR each row
BEGIN
  SELECT sq_id_ingredient.NEXTVAL
  INTO :new.id
  FROM dual;
END;

-- Формы 

CREATE SEQUENCE sq_id_form
START WITH 1 
INCREMENT BY 1 
NOMAXVALUE;

DROP TABLE tvz_tbl_form
CREATE TABLE tvz_tbl_form
(
	id INTEGER GENERATED by default on null as IDENTITY,
	id_user integer,
	form_name VARCHAR2(255),
	form_image_path VARCHAR2(255),
	porc_size float, -- кол-во порций в форме
	size_value float, --(2 единицы грамм или милилитров)
	id_type_recept integer --Муссовый тор, тарт, моссовые пироженные и т.д. должны соответствовать форма и рецепт
)

CREATE OR REPLACE TRIGGER tr_id_form before INSERT ON tvz_tbl_form FOR each row
BEGIN
  SELECT sq_id_form.NEXTVAL
  INTO :new.id
  FROM dual;
END;

SELECT * FROM tvz_tbl_form

-- Корзина

CREATE SEQUENCE sq_id_cart
START WITH 1 
INCREMENT BY 1 
NOMAXVALUE;

 
CREATE TABLE tvz_tbl_cart
(
	id INTEGER GENERATED by default on null as IDENTITY,
	id_user integer,
	create_date DATE,
	recept_id integer,
	form_id integer,
	count_by integer,
	price_rub_one float,
	price_rub_total float,
	status_cart integer,
	promo_code varchar2(50),
	id_chat integer
)

CREATE OR REPLACE TRIGGER tr_id_cart before INSERT ON tvz_tbl_cart FOR each row
BEGIN
  SELECT sq_id_cart.NEXTVAL
  INTO :new.id
  FROM dual;
END;


ALTER TABLE tvz_tbl_cart ADD id_chat integer;

-- Чат по заказу

-- чат с пользователем


-- Таблица заказов

CREATE SEQUENCE sq_id_order
START WITH 1 
INCREMENT BY 1 
NOMAXVALUE;

CREATE TABLE tvz_tbl_order
(
	id INTEGER GENERATED by default on null as IDENTITY,
	id_user integer
)


ALTER TABLE tvz_tbl_order ADD date_create DATE; 

CREATE OR REPLACE TRIGGER tr_id_order before INSERT ON tvz_tbl_order FOR each row
BEGIN
  SELECT sq_id_order.NEXTVAL
  INTO :new.id
  FROM dual;
END;

ALTER TABLE tvz_tbl_order ADD status integer;
ALTER TABLE tvz_tbl_order ADD fld_comment varchar2(1500);


INSERT INTO tvz_tbl_order  (id_user,status, date_create)  VALUES (1,1, sysdate);

SELECT * FROM tvz_tbl_order

--Статусы заказа

CREATE TABLE tvz_tbl_order_status
(
	id INTEGER ,
	status_name varchar2(255)
)
SELECT * FROM tvz_tbl_order_status
DROP TABLE tvz_tbl_order_status

-- Таблица продуктов в заказе


CREATE TABLE tvz_tbl_order_product
(
	id_order integer,
	id_product NUMBER, --[Код продукта]
	count_product NUMBER, --[Код продукта]
	name_product varchar2(255), --[Наименование продукта]
	property_text_product varchar2(1500), --[Описание продукта]
	count_porc NUMBER, --[Кол-во пориций продукта]
	price NUMBER, --[Цена за 1 товар]
	total_price number 
)


CREATE TABLE TVZ_tbl_order_delivery 
(
	id_order integer, --[номер заказа]
	date_del date, --[Дата доставки]
	time_from date, --[Интервал доставки С]
	time_to date, --[Интервал доставки ПО]
	
	phone_namber_got varchar2(50), --[Номер телефона получателя]
	IO varchar2(255), --[Имя получателя, опционально]
	
	
	town_name varchar2(255), --[Наименование населенного пункта]
	area_name varchar2(255), --[Наименоавние области]
	street_name varchar2(255), --[Наименование улицы, проспекта, бульвара и т.д.]
	house_number varchar2(255), --[Номер дома]
	part_house_number varchar2(255), --[Номер дома, корпуса]
	door_number varchar2(255), --[Номер подъезда]
	floor_naumber varchar2(50), -- [Этаж]
	door_key varchar2(50), --[Домофон]
	comment_to_delivery varchar2(500) --комментарий позаказу
)
ALTER TABLE TVZ_tbl_order_delivery ADD app_number varchar2(50)

SELECT * FROM TVZ_tbl_order_delivery

SELECT * FROM tvz_tbl_order_product
TRUNCATE TABLE tvz_tbl_order_product 


"deliveryDate":"15.07.2022",
"timeFrom":"14:00",
"timeTo":"16:00",

SELECT to_date('14:00', 'HH24:MI') FROM dual
SELECT to_date('15.07.2022', 'DD.MM.YYYY') FROM dual

-- В наличии


-- Таблица действий пользователя в приложении для предложения небходимого ему товара.

CREATE TABLE tvz_tbl_action_users
(
	user_id integer,
	uuid varchar2(255),
	date_action DATE,
	group_action integer,
	NUMBER_action integer,
   id_product integer
)

ALTER TABLE tvz_tbl_action_users ADD id_product integer;



CREATE TABLE tvz_tbl_action_users_type
(
	group_action_id integer,
	group_action_name varchar2(255),
	NUMBER_action_id integer,
	NUMBER_action_name varchar2(255)
)

SELECT * FROM tvz_tbl_action_users_type


--таблица расшифровки номера и группы типов активностей в приложении


--////////////////////////////////////////////
--////////////////////////////////////////////
-- Сервисы
--////////////////////////////////////////////
--////////////////////////////////////////////



//Список продуктов в каталоге

BEGIN
	ORDS.define_module(
		p_module_name	=>'mod_tvz',
		p_base_path		=>'mod_tvz/',
		p_items_per_page	=> 0
	);

	ORDS.define_template (
		p_module_name	=>'mod_tvz',
		p_pattern		=>'actual_katolog/'
	);

	ORDS.define_handler(
		p_module_name		=>'mod_tvz',
		p_pattern			=>'actual_katolog/',
		p_method			=>'POST',
		p_source_type		=> ORDS.source_type_plsql,
		p_source			=> 'BEGIN "INTERVAL".TVZ_REST_WEB.actual_katalog_DATA(:body); END;',
		p_items_per_page 	=> 0
	);
END;
 

CREATE OR REPLACE PACKAGE "INTERVAL".TVZ_REST_WEB
AS 
 PROCEDURE actual_katalog_DATA (vBody IN BLOB DEFAULT NULL ); -- Данные по актуальному каталогу
 
 FUNCTION clobfromlob(p_bblob blob) RETURN clob ;
END TVZ_REST_WEB;


CREATE OR REPLACE PACKAGE BODY "INTERVAL".TVZ_REST_WEB
AS 

PROCEDURE actual_katalog_DATA (vBody IN BLOB DEFAULT NULL) 
IS 
	res_cursor sys_refcursor;
	l_clob CLOB;
	l_saler_id number; --[id продавца]
	/*l_user_login varchar2(255);
	l_type_action number;
	l_lat number;
	l_lon number;
	l_date_time varchar2(255);*/
BEGIN

/*
	{
	"id_user": 1
	}
*/
	
	l_clob := clobfromlob(vBody); --[Сменили формат с blob  на clob]
	
	
	SELECT  
			to_number(json_value(l_clob, '$.id_user'))
			/*,json_value(l_clob, '$.user_login')
			,to_number(json_value(l_clob, '$.type_action'))
			,to_number(json_value(l_clob, '$.latitude'))
			,to_number(json_value(l_clob, '$.longtitude'))
			,json_value(l_clob, '$.timestamp')*/
	INTO 	l_saler_id
			/*,l_user_login 
			,l_type_action 
			,l_lat 
			,l_lon 
			,l_date_time */
	FROM dual;

		IF (l_saler_id IS null) THEN raise_application_error(-20001,'l_saler_id is null'); END IF;
	/* 	IF (l_user_login IS null) THEN raise_application_error(-20001,'l_user_login is null'); END IF;
	 	IF (l_type_action IS null) THEN raise_application_error(-20001,'l_type_action is null'); END IF;
	 	IF (l_lat IS null) THEN raise_application_error(-20001,'l_lat is null'); END IF;
	 	IF (l_lon IS null) THEN raise_application_error(-20001,'l_lon is null'); END IF;
	 	IF (l_date_time IS null) THEN raise_application_error(-20001,'l_date_time is null'); END IF;	
	*/

	
/*=====================
/* ACTION ON DATA
/*=====================
  
 */	
	/*
	INSERT INTO OHL_TBL_DATA_FOR_MODEL
	(
		 action_id 
		,user_login 
		,type_action 
		,lat 
		,lon  
		,date_time 
	)
SELECT 
			l_action_id
			,l_user_login 
			,l_type_action 
			,l_lat 
			,l_lon 
			,l_date_time 
FROM dual;
COMMIT;
	 */
	

-- Return json

 	apex_json.open_object; --1
	
		apex_json.open_array('katalog'); 
		FOR vREC IN 
		(
		SELECT DISTINCT 
			g.NAME_PRODUCT_GROUP,
			g.ID 
		FROM 
			tvz_tbl_product t1
			LEFT JOIN TVZ_GROUP_PRODUCT_NAME g ON t1.GROUP_PRODUCT = g.ID 
		WHERE 
			t1.log_active=1
			AND t1.ID_USER = l_saler_id
		ORDER  BY 
		g.ID 
		)
		LOOP 
				apex_json.open_object;
						apex_json.write('PRODUCT_GROUP',vREC.NAME_PRODUCT_GROUP);
							apex_json.open_array('product');
								FOR vRec2 IN 
								(
								SELECT DISTINCT 
									t1.PRODUCT_NAME,
									t1.TEXT_PRODUCT,
									t1.IMAGE_PATH,
									t1.count_porc,
									t1.count_shuger,
									t1.count_fruit,
									t1.id_form
								FROM 
									"INTERVAL".tvz_tbl_product t1
									LEFT JOIN "INTERVAL".TVZ_GROUP_PRODUCT_NAME g ON t1.GROUP_PRODUCT = g.ID 
								WHERE 
									t1.log_active=1
									AND g.NAME_PRODUCT_GROUP = vRec.NAME_PRODUCT_GROUP
									AND t1.ID_USER = l_saler_id	
								)
								LOOP 
									apex_json.open_object;
										apex_json.write('PRODUCT_NAME',vRec2.PRODUCT_NAME);
										apex_json.write('TEXT_PRODUCT',vRec2.TEXT_PRODUCT);
										apex_json.write('IMAGE_PATH',vRec2.IMAGE_PATH);
										apex_json.write('COUNT_PORC',vRec2.count_porc);
										apex_json.write('COUNT_SHUGER',vRec2.count_shuger);
										apex_json.write('COUNT_FRUIT',vRec2.count_fruit);
									apex_json.close_object;
								END LOOP;
							apex_json.close_array;
				apex_json.close_object;
		END LOOP;
		apex_json.close_array;
	apex_json.close_object; --/1
	EXCEPTION
	WHEN OTHERS THEN HTP.print(SQLERRM);

END;	




FUNCTION  clobfromlob(p_bblob blob) RETURN clob IS
	l_clob 			clob;
	l_dest_offsset 	integer := 1;
	l_src_offsset 	integer := 1;
	l_lang_context 	integer := dbms_lob.default_lang_ctx;
	l_warning 		integer;
BEGIN
	IF p_bblob IS NULL THEN
		RETURN NULL;
	END IF;
	dbms_lob.createTemporary (lob_loc 		=> l_clob
								,cache 		=> false);
	dbms_lob.converttoclob(dest_lob 		=> l_clob
							,src_blob 		=> p_bblob 
							,amount 		=> dbms_lob.lobmaxsize
							,dest_offset 	=> l_dest_offsset
							,src_offset 	=> l_src_offsset
							,blob_csid 		=> dbms_lob.default_csid
							,lang_context 	=> l_lang_context
							,warning 		=> l_warning);
	
				RETURN l_clob;
	END clobfromlob;

END TVZ_REST_WEB;



-- Добавление заказа пользователем

BEGIN
	ORDS.define_template (
		p_module_name	=>'mod_tvz',
		p_pattern		=>'insert_order_data/'
	);

	ORDS.define_handler(
		p_module_name		=>'mod_tvz',
		p_pattern			=>'insert_order_data/',
		p_method			=>'POST',
		p_source_type		=> ORDS.source_type_plsql,
		p_source			=> 'BEGIN "INTERVAL".TVZ_REST_WEB.INSERT_ORDER_DATA(:body); END;',
		p_items_per_page 	=> 0
	);
END;


--Сервис добавления/обновления информации по доставке в заказе

BEGIN
	ORDS.define_template (
		p_module_name	=>'mod_tvz',
		p_pattern		=>'insert_delivery_data/'
	);

	ORDS.define_handler(
		p_module_name		=>'mod_tvz',
		p_pattern			=>'insert_delivery_data/',
		p_method			=>'POST',
		p_source_type		=> ORDS.source_type_plsql,
		p_source			=> 'BEGIN "INTERVAL".TVZ_REST_WEB.INSERT_DELIVERY_DATA(:body); END;',
		p_items_per_page 	=> 0
	);
END;


-- Сервис возврата истории заказов и всех параметров с актуальным статусом 

BEGIN
	ORDS.define_template (
		p_module_name	=>'mod_tvz',
		p_pattern		=>'order_list/'
	);

	ORDS.define_handler(
		p_module_name		=>'mod_tvz',
		p_pattern			=>'order_list/',
		p_method			=>'POST',
		p_source_type		=> ORDS.source_type_plsql,
		p_source			=> 'BEGIN "INTERVAL".TVZ_REST_WEB.actual_order_DATA(:body); END;',
		p_items_per_page 	=> 0
	);
END;





--////////////////////////////////
-- Подвал
--////////////////////////////////


DECLARE
	res_cursor sys_refcursor;
BEGIN
	apex_json.initialize_clob_output;

	apex_json.open_object; --1
	
		apex_json.open_array('katalog'); 
		FOR vREC IN 
		(
		SELECT DISTINCT 
			g.NAME_PRODUCT_GROUP,
			g.ID 
		FROM 
			tvz_tbl_product t1
			LEFT JOIN TVZ_GROUP_PRODUCT_NAME g ON t1.GROUP_PRODUCT = g.ID 
		WHERE 
			t1.log_active=1
			AND t1.ID_USER = 1 --l_saler_id
		ORDER BY 
		g.ID
		)
		LOOP 
				apex_json.open_object;
						apex_json.write('PRODUCT_GROUP',vREC.NAME_PRODUCT_GROUP);
							apex_json.open_array('product');
								FOR vRec2 IN 
								(
								SELECT DISTINCT 
									t1.PRODUCT_NAME,
									t1.TEXT_PRODUCT,
									t1.IMAGE_PATH,
									t1.count_porc,
									t1.count_shuger,
									t1.count_fruit,
									t1.id_form
								FROM 
									"INTERVAL".tvz_tbl_product t1
									LEFT JOIN "INTERVAL".TVZ_GROUP_PRODUCT_NAME g ON t1.GROUP_PRODUCT = g.ID 
								WHERE 
									t1.log_active=1
									AND g.NAME_PRODUCT_GROUP = vRec.NAME_PRODUCT_GROUP
									AND t1.ID_USER = 1 --l_saler_id	
								)
								LOOP 
									apex_json.open_object;
										apex_json.write('PRODUCT_NAME',vRec2.PRODUCT_NAME);
										apex_json.write('TEXT_PRODUCT',vRec2.TEXT_PRODUCT);
										apex_json.write('IMAGE_PATH',vRec2.IMAGE_PATH);
										apex_json.write('COUNT_PORC',vRec2.count_porc);
										apex_json.write('COUNT_SHUGER',vRec2.count_shuger);
										apex_json.write('COUNT_FRUIT',vRec2.count_fruit);
									apex_json.close_object;
								END LOOP;
							apex_json.close_array;
				apex_json.close_object;
		END LOOP;
		apex_json.close_array;
	apex_json.close_object;

	dbms_output.put_line(apex_json.get_clob_output); --[Просмотр данных clob]
	apex_json.free_output;
END;


SELECT * FROM "INTERVAL".TVZ_TBL_ORDER ORDER BY id DESC 
SELECT * FROM "INTERVAL".TVZ_TBL_ORDER_PRODUCT WHERE ID_ORDER=181




--.........................................
Сервис возврата списка заказов
--.........................................




-- Список заказов и статусы по ним
SELECT 
	ORDER_ID,
	STATUS_NAME,
	DATE_ORDER
FROM 
	(
	SELECT 
		t1.id AS ORDER_ID,
		t2.STATUS_NAME,
		DATE_CREATE AS DATE_ORDER,
		row_number() over(ORDER BY DATE_CREATE desc) AS nn
	FROM 
		"INTERVAL".TVZ_TBL_ORDER t1
		LEFT JOIN TVZ_TBL_ORDER_STATUS  t2 ON t1.STATUS = t2.ID 
	WHERE 
		ID_USER = 1 AND DATE_CREATE IS NOT NULL
	) o1 WHERE nn<=20

--POSITION_PRODUCT
	SELECT 
		ID_PRODUCT,
		NAME_PRODUCT,
		COUNT_PRODUCT,
		PRICE,
		TOTAL_PRICE
	FROM 
	"INTERVAL".TVZ_TBL_ORDER_PRODUCT
	WHERE 
		ID_ORDER = 216
		
--DELIVERY_DATA		
SELECT 
	trunc(DATE_DEL) AS DATE_DELIVERY,
	PHONE_NAMBER_GOT,
	IO,
	AREA_NAME,
	TOWN_NAME,
	STREET_NAME,
	HOUSE_NUMBER,
	PART_HOUSE_NUMBER,
	DOOR_NUMBER,
	FLOOR_NAUMBER,
	DOOR_KEY
FROM 
	"INTERVAL".TVZ_TBL_ORDER_DELIVERY
WHERE 
	ID_ORDER =216


	
DECLARE
	res_cursor sys_refcursor;
BEGIN
	apex_json.initialize_clob_output;

	apex_json.open_object; --1
	
		apex_json.open_array('ORDER_DATA'); 
		FOR vREC IN 
		(
		SELECT 
			ORDER_ID,
			STATUS_NAME,
			DATE_ORDER
		FROM 
			(
			SELECT 
				t1.id AS ORDER_ID,
				t2.STATUS_NAME,
				DATE_CREATE AS DATE_ORDER,
				row_number() over(ORDER BY DATE_CREATE desc) AS nn
			FROM 
				"INTERVAL".TVZ_TBL_ORDER t1
			LEFT JOIN TVZ_TBL_ORDER_STATUS  t2 ON t1.STATUS = t2.ID 
		WHERE 
			ID_USER = l_saler_id
			AND DATE_CREATE IS NOT NULL
		) o1 WHERE nn<=20
		)
		LOOP 
				apex_json.open_object;
						apex_json.write('ORDER_ID',vREC.ORDER_ID);
						apex_json.write('STATUS_NAME',vREC.STATUS_NAME);
						apex_json.write('DATE_ORDER',vREC.DATE_ORDER);
							apex_json.open_array('PRODUCT');
								FOR vRec2 IN 
								(
									SELECT 
										ID_PRODUCT,
										NAME_PRODUCT,
										COUNT_PRODUCT,
										PRICE,
										TOTAL_PRICE
									FROM 
										"INTERVAL".TVZ_TBL_ORDER_PRODUCT
									WHERE 
										ID_ORDER =vREC.ORDER_ID
								)
								LOOP 
									apex_json.open_object;
										apex_json.write('ID_PRODUCT',vRec2.ID_PRODUCT);
										apex_json.write('NAME_PRODUCT',vRec2.NAME_PRODUCT);
										apex_json.write('COUNT_PRODUCT',vRec2.COUNT_PRODUCT);
										apex_json.write('PRICE',vRec2.PRICE);
										apex_json.write('TOTAL_PRICE',vRec2.TOTAL_PRICE);
									apex_json.close_object;
								
								END LOOP;
							apex_json.close_array;
						
							apex_json.open_array('DELIVERY');
								FOR vRec3 IN 
								(
									SELECT 
										substr(to_char(DATE_DEL, 'DD.MM.YYYY HH24:MI:SS'), 0,11 )  AS DATE_DELIVERY,
										--to_char(trunc(TIME_FROM),'YYYY.MM.DD HH24:MI:SS') AS TIME_FROM,
										substr(to_char(TIME_FROM, 'DD-MM-YYYY HH24:MI:SS'), 11,6)   AS TIME_FROM,
										substr(to_char(TIME_TO, 'DD-MM-YYYY HH24:MI:SS'), 11,6)   AS TIME_TO,
										PHONE_NAMBER_GOT,
										IO,
										AREA_NAME,
										TOWN_NAME,
										STREET_NAME,
										HOUSE_NUMBER,
										PART_HOUSE_NUMBER,
										DOOR_NUMBER,
										FLOOR_NAUMBER,
										DOOR_KEY
									FROM 
										"INTERVAL".TVZ_TBL_ORDER_DELIVERY
									WHERE 
										ID_ORDER  = vREC.ORDER_ID
								)
								LOOP 
									apex_json.open_object;
										apex_json.write('DATE_DELIVERY',vRec3.DATE_DELIVERY);
										apex_json.write('TIME_FROM',vRec3.TIME_FROM);
										apex_json.write('TIME_TO',vRec3.TIME_TO);
									
										apex_json.write('PHONE_NAMBER_GOT',vRec3.PHONE_NAMBER_GOT);
										apex_json.write('IO',vRec3.IO);

										apex_json.write('AREA_NAME',vRec3.AREA_NAME);
										apex_json.write('TOWN_NAME',vRec3.TOWN_NAME);
										apex_json.write('STREET_NAME',vRec3.STREET_NAME);
										apex_json.write('HOUSE_NUMBER',vRec3.HOUSE_NUMBER);
										apex_json.write('PART_HOUSE_NUMBER',vRec3.PART_HOUSE_NUMBER);
										apex_json.write('DOOR_NUMBER',vRec3.DOOR_NUMBER);
										apex_json.write('FLOOR_NAUMBER',vRec3.FLOOR_NAUMBER);
										apex_json.write('DOOR_KEY',vRec3.DOOR_KEY);
									apex_json.close_object;
								END LOOP;
							
							apex_json.close_array;
				apex_json.close_object;
		END LOOP;
		apex_json.close_array;
	apex_json.close_object;

	dbms_output.put_line(apex_json.get_clob_output); --[Просмотр данных clob]
	apex_json.free_output;
END;
	

PROCEDURE actual_order_DATA (vBody IN BLOB DEFAULT NULL) 
IS 
	res_cursor sys_refcursor;
	l_clob CLOB;
	l_saler_id number; --[id пользователя]
BEGIN

/*
	{
	"id_user": 1
	}
*/
	
	l_clob := clobfromlob(vBody); --[Сменили формат с blob  на clob]
	
	
	SELECT  
			to_number(json_value(l_clob, '$.id_user'))

	INTO 	l_saler_id

	FROM dual;

		IF (l_saler_id IS null) THEN raise_application_error(-20001,'l_saler_id is null'); END IF;

	
/*=====================
/* ACTION ON DATA
/*=====================
  
 */	
	/*
	INSERT INTO OHL_TBL_DATA_FOR_MODEL
	 
	 */
	

-- Return json

 		apex_json.open_object; --1
	
		apex_json.open_array('ORDER_DATA'); 
		FOR vREC IN 
		(
		SELECT 
			ORDER_ID,
			STATUS_NAME,
			DATE_ORDER
		FROM 
			(
			SELECT 
				t1.id AS ORDER_ID,
				t2.STATUS_NAME,
				DATE_CREATE AS DATE_ORDER,
				row_number() over(ORDER BY DATE_CREATE desc) AS nn
			FROM 
				"INTERVAL".TVZ_TBL_ORDER t1
			LEFT JOIN TVZ_TBL_ORDER_STATUS  t2 ON t1.STATUS = t2.ID 
		WHERE 
			ID_USER = l_saler_id
			AND DATE_CREATE IS NOT NULL
		) o1 WHERE nn<=20
		)
		LOOP 
				apex_json.open_object;
						apex_json.write('ORDER_ID',vREC.ORDER_ID);
						apex_json.write('STATUS_NAME',vREC.STATUS_NAME);
						apex_json.write('DATE_ORDER',vREC.DATE_ORDER);
							apex_json.open_array('PRODUCT');
								FOR vRec2 IN 
								(
									SELECT 
										ID_PRODUCT,
										NAME_PRODUCT,
										COUNT_PRODUCT,
										PRICE,
										TOTAL_PRICE
									FROM 
										"INTERVAL".TVZ_TBL_ORDER_PRODUCT
									WHERE 
										ID_ORDER =vREC.ORDER_ID
								)
								LOOP 
									apex_json.open_object;
										apex_json.write('ID_PRODUCT',vRec2.ID_PRODUCT);
										apex_json.write('NAME_PRODUCT',vRec2.NAME_PRODUCT);
										apex_json.write('COUNT_PRODUCT',vRec2.COUNT_PRODUCT);
										apex_json.write('PRICE',vRec2.PRICE);
										apex_json.write('TOTAL_PRICE',vRec2.TOTAL_PRICE);
									apex_json.close_object;
								
								END LOOP;
							apex_json.close_array;
							apex_json.open_array('DELIVERY');
								FOR vRec3 IN 
								(
									SELECT 
										trunc(DATE_DEL) AS DATE_DELIVERY,
										PHONE_NAMBER_GOT,
										IO,
										AREA_NAME,
										TOWN_NAME,
										STREET_NAME,
										HOUSE_NUMBER,
										PART_HOUSE_NUMBER,
										DOOR_NUMBER,
										FLOOR_NAUMBER,
										DOOR_KEY
									FROM 
										"INTERVAL".TVZ_TBL_ORDER_DELIVERY
									WHERE 
										ID_ORDER  = vREC.ORDER_ID
								)
								LOOP 
									apex_json.open_object;
										apex_json.write('DATE_DELIVERY',vRec3.DATE_DELIVERY);
										apex_json.write('PHONE_NAMBER_GOT',vRec3.PHONE_NAMBER_GOT);
										apex_json.write('IO',vRec3.IO);
										apex_json.write('AREA_NAME',vRec3.AREA_NAME);
										apex_json.write('TOWN_NAME',vRec3.TOWN_NAME);
										apex_json.write('STREET_NAME',vRec3.STREET_NAME);
										apex_json.write('HOUSE_NUMBER',vRec3.HOUSE_NUMBER);
										apex_json.write('PART_HOUSE_NUMBER',vRec3.PART_HOUSE_NUMBER);
										apex_json.write('DOOR_NUMBER',vRec3.DOOR_NUMBER);
										apex_json.write('FLOOR_NAUMBER',vRec3.FLOOR_NAUMBER);
										apex_json.write('DOOR_KEY',vRec3.DOOR_KEY);
									apex_json.close_object;
								END LOOP;
							
							apex_json.close_array;
				apex_json.close_object;
		END LOOP;
			apex_json.close_array;
			apex_json.close_object; --/1
	EXCEPTION
	WHEN OTHERS THEN HTP.print(SQLERRM);

END;	

SELECT DBMS_OBFUSCATION_TOOLKIT.MD5(INPUT =>
 UTL_RAW.CAST_TO_RAW ('Ename')) FROM dual

 
 
declare
  cln_md5raw raw(2000);
  out_raw raw(16);
begin
  cln_md5raw := utl_raw.cast_to_raw('Наш текст для хеширования');
  dbms_obfuscation_toolkit.md5(input=>cln_md5raw,checksum=>out_raw);
  -- Выводится hex версия (32 символа)
  dbms_output.put_line(lower(out_raw));
end;


DECLARE 
	encr_key RAW(32) := utl_raw.cast_to_raw('tujkej-Vepdi4-pexmez');
	encrypted_string raw(2000);
	decrypted_string VARCHAR2(2000);
	sha1_string VARCHAR2(2000);
BEGIN
  encrypted_string :=  utl_raw.cast_to_varchar2(utl_raw.cast_to_raw(dbms_crypto.Encrypt(

   src =>  UTL_I18N.STRING_TO_RAW('79950010000 sdsd f sd fsdf sdfsdfs dfsdfsdf sdf sdf sdf sdf sdf sdfsdf sdf s', 'AL32UTF8')  
	--src => utl_raw.cast_to_raw( 'Наш текст для хеширования') 
	
  -- , typ =>dbms_crypto.ENCRYPT_DES + dbms_crypto.CHAIN_CBC + dbms_crypto.PAD_ZERO -- DBMS_CRYPTO.DES_CBC_NONE   --dbms_crypto.ENCRYPT_DES + dbms_crypto.CHAIN_CBC + dbms_crypto.PAD_PKCS5,

   , typ =>dbms_crypto.ENCRYPT_DES + dbms_crypto.CHAIN_CBC + dbms_crypto.PAD_PKCS5

   
   , KEY => encr_key
    , iv => utl_raw.cast_to_raw('12345678')
   )) 
  );	
	dbms_output.put_line(lower(encrypted_string));	
END;

--------------------
SELECT UTL_I18N.STRING_TO_RAW('79950010000 sdfsdыв ывАААываыва', 'CL8MSWIN1251') FROM dual
---------------------

ALTER SESSION 

SELECT * FROM nls_database_parameters
ALTER SESSION SET NLS_LANGUAGE= 'RUSSIAN_AMERICA.CL8MSWIN1251' NLS_TERRITORY= 'AMERICA' 

ALTER SESSION SET NLS_LANGUAGE= 'RUSSIAN';


DECLARE 
	encr_key RAW(32) := utl_raw.cast_to_raw('tujkej-Vepdi4-pexmez');
	encrypted_string 	raw(2000);
	decrypted_string 	VARCHAR2(2000);
	sha1_string 		VARCHAR2(2000);
BEGIN
 decrypted_string := utl_raw.cast_to_varchar2(dbms_crypto.Decrypt(
   src => utl_raw.cast_to_raw('812d4d9bc51689b32a71c60156470c64'), 
 --src => utl_raw.cast_to_raw ('5291cded4a8e09a14977ceb8fd04ae674c08c945203f6ca478762cbadd019b1ae3bac45ac23751c7'),
  
   typ => dbms_crypto.ENCRYPT_DES + dbms_crypto.CHAIN_CBC + dbms_crypto.PAD_ZERO, --

   KEY => encr_key
   
   , iv => utl_raw.cast_to_raw('12345678')
	));
	dbms_output.put_line(lower(decrypted_string));	
END;

SELECT utl_raw.cast_to_varchar2('5bb156484a7638929a5688a07fa08e1eea0d7eddbd4409f0b672fc9f18bc1b8edb6665e8838626a0')  FROM dual



select DBMS_CRYPTO.encrypt(UTL_RAW.CAST_TO_RAW('adfasdfasdfsadf'), 4353 /* = dbms_crypto.DES_CBC_PKCS5 */, UTL_RAW.CAST_TO_RAW ('A1A2A3A4A5A6CAFE')) from dual;

select UTL_RAW.CAST_TO_varchar2(DBMS_CRYPTO.decrypt('80AA4DEA59B77C433A2142AE9CDD235A', 4353, UTL_RAW.CAST_TO_RAW ('A1A2A3A4A5A6CAFE'))) from dual;


SELECT * FROM TVZ_TBL_ORDER_DELIVERY ttod WHERE ID_ORDER =232;


SELECT 
crypto('e', 'tujkej-Vepdi4-pexmez','9950010000')  AS e FROM dual;
 
 
select
crypto('d', 'tujkej-Vepdi4-pexmez', crypto('e', 'tujkej-Vepdi4-pexmez','Управления прямых продаж')) AS d FROM dual
 
 
select
crypto('d', 'tujkej-Vepdi4-pexmez', crypto('e', 'tujkej-Vepdi4-pexmez','Управления прямых продаж')) AS d FROM dual

 
 
 
 select utl_raw.cast_to_varchar2( utl_encode.base64_encode(utl_raw.cast_to_raw(dbms_obfuscation_toolkit.md5 (input_string => 'Управления прямых продаж Управления прямых продаж Управления прямых продаж')))) base64 
   from dual
 
  select utl_raw.cast_to_varchar2( utl_encode.base64_encode(utl_raw.cast_to_raw('79950010000'))) base64 
   from dual  
 


   
 
CREATE OR REPLACE FUNCTION INTERVAL.crypto2(V_TYPE IN VARCHAR2,ENCRYPT_KEY IN VARCHAR2 DEFAULT NULL, V_STRING IN VARCHAR2)

RETURN VARCHAR2

/*

Значения V_TYPE:

  e - обратимое шифрование по алгоритму DES

  d - расшифрование по алгоритму DES

  sha1 - необратимое шифрование по алгоритму sha1 (шифрование как с ключем так и без;для шифрования без ключа , ключ указываем = null)

  

ENCRYPT_KEY - ключ

V_STRING - строка для шифрования/расшифрования

 

*/

 

IS

encr_key RAW(32) := utl_raw.cast_to_raw(ENCRYPT_KEY);

encrypted_string VARCHAR2(2000);

decrypted_string VARCHAR2(2000);

sha1_string VARCHAR2(2000);

Begin

  

IF lower(V_TYPE) = 'e'  THEN

   encrypted_string := utl_raw.cast_to_varchar2(hextoraw( dbms_crypto.Encrypt(

   src => UTL_I18N.STRING_TO_RAW(V_STRING, 'AL32UTF8') 

   , typ =>dbms_crypto.ENCRYPT_DES + dbms_crypto.CHAIN_CBC + dbms_crypto.PAD_ZERO -- DBMS_CRYPTO.DES_CBC_NONE   --dbms_crypto.ENCRYPT_DES + dbms_crypto.CHAIN_CBC + dbms_crypto.PAD_PKCS5,

   , KEY => encr_key
   , iv => utl_raw.cast_to_raw('12345678')
   ))
  );

   RETURN encrypted_string;

  END if;

 

 IF lower(V_TYPE) = 'd'  THEN

 
 decrypted_string := utl_raw.cast_to_varchar2( dbms_crypto.Decrypt(

   src => utl_raw.cast_to_raw (v_STRING),
  
   typ => dbms_crypto.ENCRYPT_DES + dbms_crypto.CHAIN_CBC + dbms_crypto.PAD_ZERO,

   KEY => encr_key
   
   , iv => utl_raw.cast_to_raw('12345678')
	));
-- 
   RETURN decrypted_string;

END if;

 

 IF lower(V_TYPE) = 'sha1'  THEN

 

 sha1_string := RAWTOHEX(DBMS_CRYPTO.HASH(

  SRC => UTL_I18N.STRING_TO_RAW(v_STRING || ENCRYPT_KEY,'UTF8'),

  TYP => 3));

RETURN sha1_string;

 

 END IF;

 

END;


select utl_raw.cast_to_varchar2( utl_encode.base64_encode(utl_raw.cast_to_raw(dbms_obfuscation_toolkit.md5 (input_string => 'Иван Иванович')))) base64 
   from dual
   
   SELECT RAWTOHEX(UTL_RAW.cast_to_raw(DBMS_OBFUSCATION_TOOLKIT.md5 (input_string=> 'EX123123456100.00'))) FROM dual

   
   
declare
   input_string       VARCHAR2 (200) := 'Иван Иванович';
   output_string      VARCHAR2 (200);
   encrypted_raw      RAW (2000);             -- stores encrypted binary text
   decrypted_raw      RAW (2000);             -- stores decrypted binary text
   num_key_bytes      NUMBER := 256/8;        -- key length 256 bits (32 bytes)
   key_bytes_raw      RAW (32);               -- stores 256-bit encryption key 
   encryption_type    PLS_INTEGER :=        -- total encryption type
                          
--   dbms_crypto.ENCRYPT_DES + dbms_crypto.CHAIN_CBC + dbms_crypto.PAD_ZERO;
   DBMS_CRYPTO.ENCRYPT_AES256
                          + DBMS_CRYPTO.CHAIN_CBC
                         + DBMS_CRYPTO.PAD_PKCS5;
begin
   DBMS_OUTPUT.PUT_LINE ('Original string: ' || input_string);
   DBMS_OUTPUT.PUT_LINE ('Encryption Type: ' || encryption_type);
   key_bytes_raw :=   DBMS_CRYPTO.RANDOMBYTES (num_key_bytes);
   DBMS_OUTPUT.PUT_LINE ('Key Bytes(RAW): ' || key_bytes_raw);
   encrypted_raw := DBMS_CRYPTO.ENCRYPT
      (
         src => UTL_I18N.STRING_TO_RAW (input_string, 'AL32UTF8'),
         typ => encryption_type,
         key => key_bytes_raw
      );
   DBMS_OUTPUT.PUT_LINE ('Encrypted string: ' || encrypted_raw);
    -- The encrypted value in the encrypted_raw variable can be used here
   decrypted_raw := DBMS_CRYPTO.DECRYPT
      (
         src => encrypted_raw,
         typ => encryption_type,
         key => key_bytes_raw
      );
   output_string := UTL_I18N.RAW_TO_CHAR (decrypted_raw, 'AL32UTF8');
   DBMS_OUTPUT.PUT_LINE ('Decrypted string: ' || output_string);
end;   
   
   
 
declare
   input_string       VARCHAR2 (200) := '883213CAAE139DDA425C5772E5DBEC46D86D10C432ED03EC829085A1223F2F90';
   output_string      VARCHAR2 (200);
   encrypted_raw      RAW (2000)  ;             -- stores encrypted binary text
   decrypted_raw      RAW (2000);             -- stores decrypted binary text
   num_key_bytes      NUMBER := 256/8;        -- key length 256 bits (32 bytes)
   key_bytes_raw      RAW (32);               -- stores 256-bit encryption key 
   encryption_type    PLS_INTEGER :=        -- total encryption type
                          
--   dbms_crypto.ENCRYPT_DES + dbms_crypto.CHAIN_CBC + dbms_crypto.PAD_ZERO;
   DBMS_CRYPTO.ENCRYPT_AES256
                          + DBMS_CRYPTO.CHAIN_CBC
                         + DBMS_CRYPTO.PAD_PKCS5;
begin
   DBMS_OUTPUT.PUT_LINE ('Original string: ' || input_string);
   DBMS_OUTPUT.PUT_LINE ('Encryption Type: ' || encryption_type);
   key_bytes_raw :=   DBMS_CRYPTO.RANDOMBYTES (num_key_bytes);
   DBMS_OUTPUT.PUT_LINE ('Key Bytes(RAW): ' || key_bytes_raw);
 
    -- The encrypted value in the encrypted_raw variable can be used here
   decrypted_raw := DBMS_CRYPTO.DECRYPT
      (
         src => UTL_I18N.STRING_TO_RAW (input_string, 'AL32UTF8'),
         typ => encryption_type,
         key => key_bytes_raw
      );
   output_string := UTL_I18N.RAW_TO_CHAR (decrypted_raw, 'AL32UTF8');
   DBMS_OUTPUT.PUT_LINE ('Decrypted string: ' || output_string);
end;   

  
SELECT UTL_I18N.STRING_TO_RAW ('883213CAAE139DDA425C5772E5DBEC46D86D10C432ED03EC829085A1223F2F90', 'AL32UTF8') FROM dual
   
   
SELECT  DBMS_OBFUSCATION_TOOLKIT.MD5 (input =>
UTL_RAW.CAST_TO_RAW (
'123123123123')) HASH_KEY FROM dual;


SELECT UTL_RAW.CAST_TO_RAW ('Иваново') FROM dual

FOR vREC IN 
		(
		WITH tbl_order AS 
		(
		SELECT 
			ORDER_ID,
			STATUS_NAME,
			substr(to_char(DATE_ORDER, 'DD.MM.YYYY HH24:MI:SS'), 0,16 ) AS DATE_ORDER
		FROM 
			(
			SELECT 
				t1.id AS ORDER_ID,
				t2.STATUS_NAME,
				DATE_CREATE AS DATE_ORDER,
				row_number() over(ORDER BY DATE_CREATE desc) AS nn
			FROM 
				"INTERVAL".TVZ_TBL_ORDER t1
			LEFT JOIN TVZ_TBL_ORDER_STATUS  t2 ON t1.STATUS = t2.ID 
		WHERE 
			ID_USER = 1 -- l_saler_id
			AND DATE_CREATE IS NOT NULL
			--AND t1.id=232
		) o1 WHERE nn<=20
		),
		tbl_price_order AS 
		(
		
									SELECT 
										o.ORDER_ID,
										o.STATUS_NAME,
										o.DATE_ORDER,
										sum(p.TOTAL_PRICE) AS TOTAL_PRICE
									FROM 
										"INTERVAL".TVZ_TBL_ORDER_PRODUCT p
										JOIN tbl_order o ON o.ORDER_ID=p.ID_ORDER 
									 GROUP BY 
									 	o.ORDER_ID,
										o.STATUS_NAME,
										o.DATE_ORDER
		)
		SELECT 
			ORDER_ID,
			STATUS_NAME,
			DATE_ORDER,
			TOTAL_PRICE
		FROM 
			tbl_price_order
		)
		LOOP 
				apex_json.open_object;
						apex_json.write('ORDER_ID',vREC.ORDER_ID);
						apex_json.write('STATUS_NAME',vREC.STATUS_NAME);
						apex_json.write('DATE_ORDER',vREC.DATE_ORDER);
						apex_json.write('TOTAL_PRICE',vREC.TOTAL_PRICE);
							apex_json.open_array('PRODUCT');
								FOR vRec2 IN 
								(
									SELECT 
										ID_PRODUCT,
										NAME_PRODUCT,
										COUNT_PRODUCT,
										PRICE,
										TOTAL_PRICE
									FROM 
										"INTERVAL".TVZ_TBL_ORDER_PRODUCT
									WHERE 
										ID_ORDER =vREC.ORDER_ID
								)


								
								
								
								
								
----------------------------------------------------
DECLARE
   l_raw    RAW (200);
   l_in_val VARCHAR2 (200) := 'Confidential Data';
BEGIN
   l_raw := utl_i18n.string_to_raw (l_in_val, 'AL32UTF8');
  DBMS_OUTPUT.put_line (l_raw);
END;	

--------////////////
DECLARE
l_key      VARCHAR2 (2000) := '1234567890123456';
l_in_val   VARCHAR2 (2000) := 'Confidential Data';
 l_mod      NUMBER
    :=   DBMS_CRYPTO.encrypt_aes128
           + DBMS_CRYPTO.chain_cbc
             + DBMS_CRYPTO.pad_pkcs5;
      l_enc      RAW (2000);
  BEGIN
      l_enc :=
        DBMS_CRYPTO.encrypt ( utl_i18n.string_to_raw (l_in_val, 'AL32UTF8'),
                              l_mod,
                              utl_i18n.string_to_raw (l_key, 'AL32UTF8') 
                               
                             );
       DBMS_OUTPUT.put_line (l_enc);
  END;


replace FUNCTION get_enc_val (p_in_val IN VARCHAR2, p_key IN VARCHAR2)
   RETURN VARCHAR2
IS
   l_enc_val   RAW (4000);
BEGIN
   l_enc_val :=
      DBMS_CRYPTO.encrypt (src      => utl_i18n.string_to_raw (p_in_val,
                                                               'AL32UTF8'
                                                              ),
                           key      => utl_i18n.string_to_raw (p_key,
                                                               'AL32UTF8'
                                                              ),
                           typ      =>   DBMS_CRYPTO.encrypt_aes128 --Механизм шифрования
                                       + DBMS_CRYPTO.chain_cbc --метод склейки
                                       + DBMS_CRYPTO.pad_pkcs5 --способ заполнения недостающих байтов
                          );
   RETURN l_enc_val;
END;

SELECT get_enc_val('123','weasdferqwe1234e') FROM dual



 
VARIABLE enc_val varchar2(2000);
 
 
SELECT  crypto3('e','uPDrn12Vb4GnWv0J', 'v0JPBNRBhKv1MuPDrn12Vb4GnW','79950010000') FROM dual
 
SELECT  crypto3('d','uPDrn12Vb4GnWv0J', 'v0JPBNRBhKv1MuPDrn12Vb4GnW','12A968250BCDD7D104A22521F45DEE810F') FROM dual
 
 ---------------------------
 
 CREATE OR REPLACE FUNCTION "INTERVAL".crypto3(V_TYPE IN VARCHAR2, ENCRYPT_KEY IN VARCHAR2 DEFAULT NULL, SOLT IN VARCHAR2 DEFAULT NULL, V_STRING IN VARCHAR2)

RETURN VARCHAR2

/*

Значения V_TYPE:

  e - обратимое шифрование по алгоритму DES

  d - расшифрование по алгоритму DES

  sha1 - необратимое шифрование по алгоритму sha1 (шифрование как с ключем так и без;для шифрования без ключа , ключ указываем = null)

  

ENCRYPT_KEY - ключ

V_STRING - строка для шифрования/расшифрования

 

*/

 

IS

out_val varchar2(2000);
solt_val varchar2(2000);
l_key      VARCHAR2 (2000) := ENCRYPT_KEY;
l_in_val   VARCHAR2 (2000) := V_STRING;
l_mod      NUMBER
          :=   DBMS_CRYPTO.encrypt_aes128
             + DBMS_CRYPTO.chain_cbc
             + DBMS_CRYPTO.pad_pkcs5
              + DBMS_CRYPTO.PAD_ZERO ;
l_enc      RAW (2000);

BEGIN
	
IF lower(V_TYPE) = 'e'  THEN
       l_enc :=
          DBMS_CRYPTO.encrypt (
          						utl_i18n.string_to_raw (l_in_val, 'AL32UTF8'),
                                l_mod,
                               	utl_i18n.string_to_raw (l_key, 'AL32UTF8'),
                               	iv => utl_raw.cast_to_raw(solt_val)
                              );
      out_val := RAWTOHEX (l_enc);     
RETURN out_val;
END if;

IF lower(V_TYPE) = 'd'  THEN 
  l_dec :=
           DBMS_CRYPTO.decrypt (HEXTORAW (l_in_val),
                               l_mod,
                               utl_i18n.string_to_raw (l_key, 'AL32UTF8'),
                                iv => utl_raw.cast_to_raw(solt_val)
                             );
     -- DBMS_OUTPUT.put_line ('Decrypted=' || utl_i18n.raw_to_char (l_dec));
   return  utl_i18n.raw_to_char (l_dec);
END if;

END;




  DECLARE
  	out_val varchar2(2000);
 	solt_val varchar2(2000);
    l_key      VARCHAR2 (2000) := ENCRYPT_KEY;
    l_in_val   VARCHAR2 (2000) := V_STRING;
       l_mod      NUMBER
          :=   DBMS_CRYPTO.encrypt_aes128
             + DBMS_CRYPTO.chain_cbc
             + DBMS_CRYPTO.pad_pkcs5
              + DBMS_CRYPTO.PAD_ZERO ;
        l_enc      RAW (2000);
    BEGIN
	
	    IF lower(V_TYPE) = 'e'  THEN
       l_enc :=
          DBMS_CRYPTO.encrypt (utl_i18n.string_to_raw (l_in_val, 'AL32UTF8'),
                                l_mod,
                               utl_i18n.string_to_raw (l_key, 'AL32UTF8'),
                               iv => utl_raw.cast_to_raw(solt_val)
                              );
      enc_val := RAWTOHEX (l_enc);     
  RETURN l_enc;
  END if;
    
    /
  DECLARE
      l_key      VARCHAR2 (2000) := '1234567890123456';
      l_in_val   RAW (2000)      := HEXTORAW ('C49769E445A0EF4D15354DD99D8CC41892CCFAE28C5C7BAB96496C2ECD1500B6694E9E2C97BDFAA49B6EA32EED6923F20B');
     
             
       l_dec      RAW (2000);
    BEGIN
       l_dec :=
           DBMS_CRYPTO.decrypt (l_in_val,
                               l_mod,
                               utl_i18n.string_to_raw (l_key, 'AL32UTF8'),
                                iv => utl_raw.cast_to_raw(solt_val)
                             );
      DBMS_OUTPUT.put_line ('Decrypted=' || utl_i18n.raw_to_char (l_dec));
     END;



    
    select RAWTOHEX('TTl2kEkCV2zh8ocac4QQlQ==') from dual
    
       --- Также 64eas
   SELECT utl_raw.cast_to_varchar2(utl_encode.base64_encode(utl_raw.cast_to_raw('1231231231'))) FROM dual;
   SELECT utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw('gVR7a04tL/EC1kh4vzZj8g=='))) FROM dual;
 
   
TRUNCATE table"INTERVAL".TVZ_TBL_ORDER_DELIVERY

SELECT * FROM  "INTERVAL".TVZ_TBL_ORDER_PRODUCT
SELECT * FROM "INTERVAL".TVZ_TBL_ORDER_STATUS
SELECT * FROM "INTERVAL".TVZ_TBL_ORDER_DELIVERY
TRUNCATE table"INTERVAL".TVZ_TBL_ORDER
  --------------------  256   ---------------
  
  
  DECLARE
   input_string       VARCHAR2 (200) :=  'Secret Message';
   output_string      VARCHAR2 (200);
   encrypted_raw      RAW (2000);             -- stores encrypted binary text
   decrypted_raw      RAW (2000);             -- stores decrypted binary text
   num_key_bytes      NUMBER := 256/8;        -- key length 256 bits (32 bytes)
   key_bytes_raw      RAW (32);               -- stores 256-bit encryption key
   encryption_type    PLS_INTEGER :=          -- total encryption type
                            DBMS_CRYPTO.ENCRYPT_AES256
                          + DBMS_CRYPTO.CHAIN_CBC
                          + DBMS_CRYPTO.PAD_PKCS5;
   iv_raw             RAW (16);

BEGIN
   DBMS_OUTPUT.PUT_LINE ( 'Original string: ' || input_string);
   key_bytes_raw := DBMS_CRYPTO.RANDOMBYTES (num_key_bytes);
   iv_raw        := DBMS_CRYPTO.RANDOMBYTES (16);
   encrypted_raw := DBMS_CRYPTO.ENCRYPT
      (
         src => UTL_I18N.STRING_TO_RAW (input_string,  'AL32UTF8'),
         typ => encryption_type,
         key => key_bytes_raw,
         iv  => iv_raw
      );
     
    DBMS_OUTPUT.PUT_LINE ('encrypted_raw: ' || encrypted_raw);
    -- The encrypted value "encrypted_raw" can be used here

   decrypted_raw := DBMS_CRYPTO.DECRYPT
      (
         src => encrypted_raw,
         typ => encryption_type,
         key => key_bytes_raw,
         iv  => iv_raw
      );
   output_string := UTL_I18N.RAW_TO_CHAR (decrypted_raw, 'AL32UTF8');
 
   DBMS_OUTPUT.PUT_LINE ('Decrypted string: ' || output_string); 
 
END;

  
    